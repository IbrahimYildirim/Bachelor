4.3 Web Service design

4.3.1 Messaging protocol

The application requires sharing of data between the server and the client application. Additionally the server has to support both  iOs and Android. The communication between the server and the client application has to be agnostic.

The standard way to acomplish that is to create SOAP or REST api.

SOAP (Simple object access protocol) is XML based protocol consisting of three parts:
	an envelope, which defines the message structure and how to process it
	a set of encoding rules for expressing instances of application-defined datatypes
	a convention for representing procedure calls and responses

REST (Representational state transfer) Web Services are defined with the following aspects:
	base URI, such as http://ourapp.com/api/
	an Internet media type for the data exchanged. This is usually JSON
	standard HTTP methods (GET, PUT, POST, or DELETE)

It was decided to go with REST because it is more lightweight, more suited for the basic create, reade, update, delete (CRUD) use case that is necessary for this Web Service. 

4.3.3 Framework 

The Web Service is implemented in Sails.js framework running on top of Node.js plattform.

We chose Node.js for the following reasons:
	Fast performance and data processing
	Relatively easy to set up load balancing, clusters and scale up if the need arises
	Open source and a heatlhy ecosystem of open source packages
	Developers were already familiar with it

Sails.js makes it easy to build custom, enterprise-grade Node.js apps. It is designed to emulate the familiar MVC pattern of frameworks like Ruby on Rails, but with support for the requirements of modern apps: data-driven APIs with a scalable, service-oriented architecture.

The decision to use Sails.js was made to abstract away most of the boiler-plate code that would otherwise be required. It also has a very steep learning curve.

4.3.4 Database

Sails.js allows developers to utilize powerful data access layer with Object Relation Mapping (ORM) called Waterline which works with any database and can even combine multiple databases. To use Waterline properly we define a model and database-adapter for it to use such as:

[code sample 1]
	


The application, which is built for the project, requires extensive sharing of data between the server
and the client application. To provide the means of communication a set of common standards and
protocols must be established between the client and the server. Since client and server sides are
written in different programing languages the selection of standards and protocols are playing a
crucial role and influences the architecture of the system. To make the right choice and accomplish
the desired outcome the system must comply to following requirements:

	Decoupling the functionality from the presentation of the application
	Web server must be operating system independent
	Developers should have extensive knowledge of the programming language in which the
	web server is implemented
	Ease of manipulation and storage of the data in database

To fulfill the requirements a selection of frameworks, protocols and standards were considered and
summarized in the following paragraph.
To satisfy the first requirement a web server must be selected. A web server is a computer system
that process requests over Hypertext Transfer Protocol and the selection process is quite
challenging. In almost every programming language a web server has been already developed and a
skilled person can also develop one from scratch, therefore to evaluate the selection of available
web servers and frameworks the criteria for the selection for the project purpose are as follow:

	Resists failures
	It does what the client expects and is reliable
	Relatively simple process of scaling and load balancing
	Accessibility of different vendor databases - simultaneously
	Only secure and trusted client access to web server

From the requirements above we chose Node.js as our web server framework. For the project specifications
the main purpose of the web server is to provide interface to the server database and respond to the
basic Create, Read, Update and Delete (CRUD) functions for user data, so the data can be
accessible from any device and will be synchronized across the client devices. The user data
mainly consists of simple data types - strings, integers, longs, arrays, booleans and date times, the
data is sanitized, validated and save to the database.


In the heart of Node.js is an asynchronous event driven JavaScript framework where no function is directly performing I/O operations, therefore there are no worries of deadlocking processes and many connections can be handled concurrently, thus developers can easily develop scalable
solutions. To go even one step further and bring structure to the Node.js web server a framework called Sails.js can be utilized which emulates real time Model View Controller (MVC) design pattern for Node.js and adds a bucket of useful features. Sails.js allows developers to utilize 
powerful data access layer with Object Relation Mapping (ORM) called Waterline which works with any database and can even combine multiple databases. 
To use Waterline properly we define a model and database-adapter for it to use such as:

	***code sample e.g. Event.js**

Waterline then exposes an object that we can call basic methods on such as create, update, destroy and it uses the database adapter to call the corresponding commands on the database.


To deploy our webserver on a public URL we chose to use Heroku. It is a plattform as a service that supports code written in Node.js among other languages. It allows us to deploy our webserver incredibly easily by simply pushing our source source code through Git source control such as:
	
	git push heroku master

Heroku then locates the dependency file package.json which is part of every Node.js application, install the dependencies using Node Package Manager (npm). The only separate instruction we need to provide to heroku is file named Procfile which specifies how to run our application.
This is how our Procfile looks. 

   web: sails lift

Heroku now handles compiling and building our source code, installing the dependencies, choosing the hardware to run it on, starting the application, exposing it publicly. It also makes it easy to scale our application up in the case we start to get too many requests or using too much RAM etc. All we need to focus on is the application logic. The downside is that as our application grows we will have to pay a monthly fee for using Heroku. We consulted this with our client and he deemed that acceptable, opting to focus our time on application logic not deployment infrastructure.


To persist our application data we had to use a database. The biggest choice we faced was using a traditional relational database such as MySQL or PostgreSQL or an object database (noSQL) such as MongoDB. After analyzing our data model and seeing relational relationships pop up again and again we decided to go with a relational database.
Some other important requirements for our database were:
	
	It is easy to set up with Node.js
	It is open source and free to use
	It has good community behind it to help us solve any issues we run into
	It is supported by Heroku

We seriously considered MySQL and PostgreSQL. Both of them fulfilled requirements 1-3 but in the end we had to choose PostgreSQL because of it is supported by Heroku.

